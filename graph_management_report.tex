\documentclass[12pt,a4paper]{article}
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage{amsmath}
\usepackage{amsfonts}
\usepackage{amssymb}
\usepackage{graphicx}
\usepackage{geometry}
\usepackage{listings}
\usepackage{xcolor}
\usepackage{hyperref}
\usepackage{enumitem}
\usepackage{tikz}
\usepackage{pgfplots}

\geometry{margin=2.5cm}

% Code listing style
\lstset{
    language=Python,
    basicstyle=\ttfamily\small,
    keywordstyle=\color{blue},
    commentstyle=\color{green!60!black},
    stringstyle=\color{red},
    numbers=left,
    numberstyle=\tiny,
    stepnumber=1,
    numbersep=5pt,
    backgroundcolor=\color{gray!10},
    showspaces=false,
    showstringspaces=false,
    showtabs=false,
    frame=single,
    tabsize=2,
    captionpos=b,
    breaklines=true,
    breakatwhitespace=false,
    escapeinside={\%*}{*)}
}

\title{\textbf{Graph Management Exercises Report}\\
\large Breadth-First Search, Depth-First Search, and Graph Coloring}
\author{Sara Sherif Daoud Saad}
\date{\today}

\begin{document}

\maketitle

\tableofcontents
\newpage



\section{Breadth-First Search and Bipartite Graphs}

\subsection{Exercise 1: BFS Distance Computation}

\textbf{Problem:} Using graph traversal algorithms, propose an algorithm that computes the number of edges between a given vertex and all other vertices. 

\textbf{Solution:}  I adjusted the BFS algorithm to find the shortest paths in unweighted graphs by exploring vertices level by level.

\begin{lstlisting}[caption=BFS Distance Computation, label=lst:bfs_distances]
# See exercise1_bfs_distances.py for complete implementation
def compute_distances_from_vertex(graph, start_vertex):
    distances = {}
    for vertex in graph:
        distances[vertex] = float('inf')
    
    distances[start_vertex] = 0
    queue = deque([start_vertex])
    
    while queue:
        current_vertex = queue.popleft()
        for neighbor in graph[current_vertex]:
            if distances[neighbor] == float('inf'):
                distances[neighbor] = distances[current_vertex] + 1
                queue.append(neighbor)
    
    return distances
\end{lstlisting}

\textbf{Time Complexity:} O(V + E) where V is the number of vertices and E is the number of edges.


\textbf{Implementation:} See \texttt{exercise1\_bfs\_distances.py} for complete implementation with custom Queue class.

\subsection{Exercise 2: Odd Cycles Analysis}

\textbf{Problem:} Given the following cycles with even and odd length (with the distances or depths from the grey vertex), what do you think about the case of graphs with an odd cycle (in number of edges)? Is this a characteristic property? State the general case.

\textbf{Solution:} 

\textbf{Observation from the graphs:}
\begin{itemize}
    \item A graph with only even cycles can be bipartite
    \item A graph with an odd cycle cannot be bipartite
\end{itemize}

\textbf{Characteristic property:}
\begin{itemize}
    \item A graph is bipartite $\Leftrightarrow$ it contains no odd-length cycles
\end{itemize}

\textbf{General case:}
\begin{itemize}
    \item Odd cycles break bipartiteness; even cycles do not
\end{itemize}

\textbf{Mathematical Foundation:}
\begin{itemize}
    \item In bipartite graphs, all cycles must have even length
    \item If a graph contains an odd cycle, it cannot be bipartite
    \item This provides a necessary and sufficient condition for bipartiteness
    \item The presence of an odd cycle is a definitive proof that a graph is not bipartite
\end{itemize}

\subsection{Exercise 3: Odd Cycle Detection Algorithm}

\textbf{Problem:} Propose an algorithm that determines if a graph contains an odd cycle.

\textbf{Solution:} Use BFS with vertex coloring to detect odd cycles. If we find a back edge connecting two vertices of the same color, we have found an odd cycle.

\begin{lstlisting}[caption=Odd Cycle Detection, label=lst:odd_cycle]
# See exercise3and5_odd_cycle_detection_bipartite.py for complete implementation
def has_odd_cycle(graph):
    color = {}
    for node in graph:
        if node not in color:
            queue = deque([node])
            color[node] = 0
            
            while queue:
                u = queue.popleft()
                for v in graph[u]:
                    if v not in color:
                        color[v] = 1 - color[u]
                        queue.append(v)
                    elif color[v] == color[u]:
                        return True
    return False
\end{lstlisting}

\textbf{Time Complexity:} O(V + E)
\textbf{Implementation:} See \texttt{exercise3and5\_odd\_cycle\_detection\_bipartite.py} for complete implementation with detailed comments and test cases.

\subsection{Exercise 4: Bipartite Graphs and Odd Cycles}

\textbf{Problem:} In a bipartite graph, can there be a cycle with an odd number of edges? Is this a characteristic property? Justify your answer.

\textbf{Answer:} No, bipartite graphs cannot contain odd cycles. This is indeed a characteristic property.

\textbf{Property:}
\begin{itemize}
    \item Bipartite graphs cannot have odd cycles
\end{itemize}

\textbf{Justification:} Bipartite graphs divide vertices into two sets, all edges go across sets. If there were an odd cycle, you would need an edge connecting vertices in the same set, which is impossible.\\


\textbf{Mathematical Foundation:}
\begin{enumerate}
    \item In a bipartite graph, vertices can be divided into two disjoint sets U and V
    \item Every edge connects a vertex in U to a vertex in V
    \item Any cycle must alternate between sets U and V
    \item To return to the starting vertex, we need an even number of steps
    \item Therefore, all cycles in bipartite graphs have even length
\end{enumerate}

\subsection{Exercise 5: Bipartite Graph Detection}

\textbf{Problem:} Propose an algorithm that allows to determine if a graph is bipartite. Test your algorithm on the following graph. Is it bipartite? Justify your answer.

\textbf{Solution:} BFS-based bipartite detection algorithm.

This is the same BFS coloring algorithm. If you can color the graph with 2 colors without conflict, it's bipartite.


\textbf{Result:} If \texttt{has\_odd\_cycle} returns \texttt{True}, the graph is not bipartite. If \texttt{False}, it is bipartite.

\textbf{Algorithm:} The same BFS coloring algorithm from Exercise 3 can be used to detect bipartiteness.

\section{Depth-First Search and 2-Colorable Graphs}

\subsection{Exercise 1: Link with Previous Exercise}

\textbf{Problem:} What is the link with the previous exercise? Justify your answer.

\textbf{Answer:} 

\textbf{1) Link with the previous exercise}

In the previous exercise, we studied BFS, odd cycles, and bipartite graphs.
A graph is bipartite $\Leftrightarrow$ 2-colorable $\Leftrightarrow$ contains no odd cycle.
So the question of 2-colorability is exactly the same as asking whether the graph is bipartite.

\textbf{Justification:}
\begin{itemize}
\item If a graph is 2-colorable, then all cycles are even (so no odd cycle)
\item If there's an odd cycle, 2-coloring fails
\item Hence, the link is that checking bipartiteness (with BFS in the previous exercise) is equivalent to checking 2-colorability (with DFS here)
\end{itemize}



\textbf{Implementation:} See \texttt{dfs\_exercise2\_2colorability\_algorithm.py} for detailed analysis.

\subsection{Exercise 2: 2-Colorability Algorithm}

\textbf{Problem:} We want to write an algorithm, inspired by DFS search which takes as input a graph G(V, E) and which returns a pair (result, color) where result is true if the graph is colorable, false otherwise and color is a dictionary associating a color 0 or 1 to each vertex. This algorithm should stop as soon as possible when the graph is not 2-colorable. Propose an iterative version or a recursive version.

\textbf{Solution:} 

We need an algorithm that:
\begin{itemize}
\item Uses DFS traversal
\item Assigns alternating colors (0 and 1)
\item Stops immediately when a conflict (same color on adjacent vertices) is found
\item Returns (result, color)
\end{itemize}

\textbf{Recursive DFS implementation:}

\begin{lstlisting}[caption=Recursive DFS 2-Colorability Detection, label=lst:dfs_recursive]
def is_2_colorable_dfs(graph):
    color = {}
    
    def dfs(node, c):
        color[node] = c
        for neighbor in graph[node]:
            if neighbor not in color:
                if not dfs(neighbor, 1 - c):  # alternate color
                    return False
            elif color[neighbor] == color[node]:
                return False  # conflict: same color for adjacent nodes
        return True
    
    # handle disconnected graphs
    for v in graph:
        if v not in color:
            if not dfs(v, 0):
                return False, color
    return True, color
\end{lstlisting}

\textbf{Iterative DFS implementation (stack-based):}

\begin{lstlisting}[caption=Iterative DFS 2-Colorability Detection, label=lst:dfs_iterative]
def is_2_colorable_dfs_iterative(graph):
    color = {}
    
    for start in graph:
        if start not in color:
            stack = [(start, 0)]
            
            while stack:
                node, c = stack.pop()
                
                if node in color:
                    if color[node] != c:
                        return False, color  # conflict
                    continue
                
                color[node] = c
                
                for neighbor in graph[node]:
                    stack.append((neighbor, 1 - c))
    
    return True, color
\end{lstlisting}

\textbf{Example usage:}
\begin{lstlisting}[caption=Example Usage, label=lst:example_usage]
graph = {
    0: [1, 2],
    1: [0, 3],
    2: [0, 3],
    3: [1, 2]
}

print(is_2_colorable_dfs(graph))
# Output: (True, {0:0, 1:1, 2:1, 3:0}) â†’ the graph is 2-colorable.
\end{lstlisting}

If there's an odd cycle, the function stops early and returns (False, color).

\textbf{Features:}
\begin{itemize}
\item Early termination when conflict is found
\item Returns (result, color) pair as specified
\item Both iterative and recursive versions
\item Time complexity: O(V + E)
\item Handles disconnected graphs
\end{itemize}



\section{Code References}

\begin{itemize}
    \item \texttt{exercise1\_bfs\_distances.py} - BFS distance computation
    \item \texttt{exercise3and5\_odd\_cycle\_detection\_bipartite.py} - Odd cycle detection and bipartite graphs
    \item \texttt{dfs\_exercise2\_2colorability\_algorithm.py} - 2-colorability algorithm
\end{itemize}

\end{document}